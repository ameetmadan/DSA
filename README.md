# Data Science and Algorithms
My coursework for the "Informatics II" (Data Structures and Algorithms) course at University of ZÃ¼rich

- Introduction, basic sorting, recursion (chap 1 in CLRS)
- Complexity and correctness (chap 2, 3 in CLRS)
- Divide and conquer, recurrences (chap 4 in CLRS)
- Heap sort, quick sort (chap 6, 7 in CLRS)
- Pointers, lists, sets, abstract data types (chap 10 in CLRS)
- Trees, red-black trees (chap 12, 13 in CLRS)
- Hash tables (chap 11 in CLRS)
- Dynamic programming (chap 15 in CLRS)
- Graph algorithms (chap 22, 23, 24 in CLRS)

SL01
- [Algorithms](#algorithms)
    - [What is an algorithm?](#what-is-an-algorithm)
    - [How to develop an algortihm?](#how-to-develop-an-algortihm)
      - [Example: Linear search in Pseudocode](#example-linear-search-in-pseudocode)
    - [Prime number filter in pseudocode](#prime-number-filter-in-pseudocode)
    - [Sorting algotihms](#sorting-algotihms)
      - [Bubble sort](#bubble-sort)
      - [Selection sort](#selection-sort)
      - [Insertion sort](#insertion-sort)
    - [Recursion algotihms](#recursion-algotihms)
      - [Fibonacci numbers](#fibonacci-numbers)
      - [Odd and even numbers](#odd-and-even-numbers)
      - [Drawing figures with recursion](#drawing-figures-with-recursion)

SL02
- [Algortihmic complexity](#algortihmic-complexity)
    - [How do we define what degree of complexity an algortihm has?](#how-do-we-define-what-degree-of-complexity-an-algortihm-has)
    - [Random access machine](#random-access-machine)
    - [Analysis of insertion sort](#analysis-of-insertion-sort)
    - [Best, worst and average case](#best-worst-and-average-case)
    - [Example: Binary search](#example-binary-search)
- [Correctness](#correctness)
    - [Loop invariants](#loop-invariants)
- [Asymptotic complexity](#asymptotic-complexity)
    - [Logarithmic rules](#logarithmic-rules)
- [Special case analysis](#special-case-analysis)

SL03
- [Divide and conquer](#divide-and-conquer)
- [Reccurences](#reccurences)
  - [Repeated substitution](#repeated-substitution)
  - [Substitution method](#substitution-method)
  - [Recursion trees](#recursion-trees)
- [Master method](#master-method)
  - [Decreasing recurrences](#decreasing-recurrences)
  - [Case 1, 2 and 3](#case-1-2-and-3)

SL04
- [Heap sort](#heap-sort)
  - [What is a binary tree?](#what-is-a-binary-tree)
  - [How do you build a heap?](#how-do-you-build-a-heap)
    - [Complete binary trees](#complete-binary-trees)
    - [Nearly complete binary trees](#nearly-complete-binary-trees)
  - [Heapify](#heapify)
- [Quick sort](#quick-sort)
  - [Lomuto partitioning](#lomuto-partitioning)
  - [Hoare partitioning](#hoare-partitioning)
  - [Comparison of Lomuto vs. Hoare](#comparison-of-lomuto-vs-hoare)

SL05
- [Pointers](#pointers)
  - [What is a pointer?](#what-is-a-pointer)
  - [How and when is a pointer used in C?](#how-and-when-is-a-pointer-used-in-c)
- [Linked lists](#linked-lists)
  - [What is a linked list?](#what-is-a-linked-list)
  - [How and when is a linked list used in C?](#how-and-when-is-a-linked-list-used-in-c)
    - [List traversal](#list-traversal)
    - [Adding data to list (88, 52, 12)](#adding-data-to-list-88-52-12)
    - [Insert an element](#insert-an-element)
    - [Delete an element](#delete-an-element)
    - [Reversing the linked list](#reversing-the-linked-list)
  - [Doubly linked list](#doubly-linked-list)
- [Stacks](#stacks)
  - [What is a stack?](#what-is-a-stack)
  - [How and when is a stack used in C?](#how-and-when-is-a-stack-used-in-c)
- [Queues](#queues)
  - [What is a queue?](#what-is-a-queue)
  - [How and when is a queue used in C?](#how-and-when-is-a-queue-used-in-c)
- [Ordered lists](#ordered-lists)
  - [What is a ordered list?](#what-is-a-ordered-list)
  - [How and when is a ordered list used in C?](#how-and-when-is-a-ordered-list-used-in-c)